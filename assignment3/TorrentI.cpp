// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2.5
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:1673

#include "TorrentI.h"

// Implementation skeleton constructor
Torrent_P2T_i::Torrent_P2T_i (CORBA::ORB_ptr orb) : orb_ (CORBA::ORB::_duplicate (orb))
{
    fileName_ = null;
}

// Implementation skeleton destructor
Torrent_P2T_i::~Torrent_P2T_i (void)
{
}

::RegReply * Torrent_P2T_i::_cxx_register (
    const char * client_id,
    const char * peer_ior_val,
    const char * file_name)
{
    if (file_name != NULL)
    {
        if (fileName_ == NULL)
        {
            fileName_ = str(file_name);
            // make chunk map
            PeerToChunkMap chunkMap ;
            chunkMap.chunks_owned = 0;
            chunkMap.client_id = str(client_id);
            chunkMap.peer_ior_val = str(peer_ior_val);
            // store chunk map
            ownershipList_.push_back(chunkMap);

            RegReply reply;
            reply.num_chunks = numberOfChunks_;
            reply.server_ior_val = ownIOR_;
        }
        else
        {
            if (fileName_.compare(str(file_name))
        {
            fileName_ = str(file_name);
                // make chunk map
                PeerToChunkMap chunkMap ;
                chunkMap.chunks_owned = 0;
                chunkMap.client_id = str(client_id);
                chunkMap.peer_ior_val = str(peer_ior_val);
                // store chunk map
                ownershipList_.push_back(chunkMap);

                RegReply reply;
                reply.num_chunks = numberOfChunks_;
                reply.server_ior_val = ownIOR_;
            }
            else
            {
                throw Torrent::NotFound("filename asked for by peer not on this tracker");
            }
        }
    }
    else  // was null, throw error
    {
        throw Torrent::NotFound("filename asked for by peer was null");
    }
}

void Torrent_P2T_i::leave (
  const char * client_id,
  ::CORBA::ULongLong time_in_miliseconds)
{
  // Add your implementation here
}

::OwnershipList * Torrent_P2T_i::refresh (
  const char * client_id,
  const char * file_name,
  const ::ChunkNumbers & chunks_owned)
{
  // Add your implementation here
}

void Torrent_P2T_i::sendNumChunks (
  const char * file_name,
  const char * server_ior_val,
  ::CORBA::Long number_of_chunks)
{
  // Add your implementation here
}

void Torrent_P2T_i::shutdown (
  void)
{
  // Add your implementation here
}

// Implementation skeleton constructor
Torrent_P2P_i::Torrent_P2P_i (void)
{
}

// Implementation skeleton destructor
Torrent_P2P_i::~Torrent_P2P_i (void)
{
}

::Chunk * Torrent_P2P_i::getChunk (
  const char * file_name,
  ::CORBA::Long chunckNumber)
{
  // Add your implementation here
}

void Torrent_P2P_i::shutdown (
  void)
{
  // Add your implementation here
}

